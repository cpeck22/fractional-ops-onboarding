import OpenAI from 'openai';
import { getPlayPromptConfig, getVariablesByCategory, type HighlightCategory } from './play-prompts';

/**
 * Highlight output content using OpenAI to identify Octave elements and personalization
 * This uses semantic inference to match output text to input elements (persona, use cases, etc.)
 * 
 * Now enhanced with play-specific prompt templates and variable mappings for accurate highlighting
 */
export async function highlightOutput(
  outputContent: string,
  runtimeContext: {
    personas?: Array<{ oId: string; name: string; description?: string }>;
    useCases?: Array<{ oId: string; name: string; desiredOutcome?: string; blocker?: string }>;
    clientReferences?: Array<{ oId: string; name: string }>;
  },
  playCode?: string
): Promise<string> {
  const openaiApiKey = process.env.OPENAI_API_KEY;
  
  if (!openaiApiKey) {
    console.warn('‚ö†Ô∏è OPENAI_API_KEY not configured, skipping highlighting');
    return outputContent; // Return original content if no API key
  }

  const openai = new OpenAI({
    apiKey: openaiApiKey
  });

  // Get play-specific prompt configuration if playCode is provided
  const playConfig = playCode ? getPlayPromptConfig(playCode) : null;
  const variablesByCategory = playCode ? getVariablesByCategory(playCode) : null;

  // Build context summary for the LLM
  const personaNames = runtimeContext.personas?.map(p => p.name).join(', ') || 'None';
  const useCaseNames = runtimeContext.useCases?.map(uc => uc.name).join(', ') || 'None';
  const useCaseOutcomes = runtimeContext.useCases?.map(uc => uc.desiredOutcome).filter(Boolean).join(', ') || 'None';
  const useCaseBlockers = runtimeContext.useCases?.map(uc => uc.blocker).filter(Boolean).join(', ') || 'None';
  const referenceNames = runtimeContext.clientReferences?.map(r => r.name).join(', ') || 'None';

  // CEO's example as few-shot learning
  const exampleOutput = `<HIGHLIGHTED_OUTPUT_EXAMPLE>
  <LEGEND>
    <OCTAVE_ELEMENTS>
      <persona>Persona</persona>
      <segment>Segment</segment>
      <usecase_outcome>Use Case (Desired Outcome)</usecase_outcome>
      <usecase_blocker>Use Case (Problem/Blocker)</usecase_blocker>
      <cta_leadmagnet>CTA (Lead Magnet)</cta_leadmagnet>
    </OCTAVE_ELEMENTS>
    <OCTAVE_CONTENT_AGENT_PERSONALIZATION>
      <personalization>Personalized / Claire Generated Info / Clay Info / etc</personalization>
    </OCTAVE_CONTENT_AGENT_PERSONALIZATION>
  </LEGEND>

  <EMAIL>
    <SUBJECT>
      How <persona>CEOs</persona> run the business on <usecase_outcome>clean numbers</usecase_outcome> <usecase_blocker>without living in QuickBooks</usecase_blocker>
    </SUBJECT>

    <BODY>
      Hi <personalization>John</personalization>,<br/><br/>

      Most <persona>CEOs</persona> I talk to <segment>under ~$10M</segment> want the same thing:
      <usecase_outcome>to run the business on clean, up-to-date numbers every month</usecase_outcome>
      instead of <usecase_blocker>gut feel</usecase_blocker>.<br/><br/>

      We've been working on a simple way around that:<br/>
      ‚Ä¢ Take all of the day-to-day bookkeeping off the <persona>CEO</persona>/ops plate<br/>
      ‚Ä¢ Close the books by the same date every month (e.g. by the 10th)<br/>
      ‚Ä¢ Deliver a one-page <persona>CEO</persona> finance snapshot (cash, profit, runway, key ratios) in plain English<br/><br/>

      Short version:
      <usecase_outcome>you forward invoices/receipts or keep using your tools as you do now; our team keeps the books current and sends you a monthly finance brief you can actually use to make decisions</usecase_outcome>.<br/><br/>

      If you'd like a bit more detail, I put this into a one-page
      <cta_leadmagnet>"Monthly Finance Snapshot" template</cta_leadmagnet>
      you can steal and run with your current team (<cta_leadmagnet>Link here</cta_leadmagnet>).<br/><br/>

      P.S. If your goal is to run <personalization>McGreggor Law</personalization> on
      <usecase_outcome>clean numbers each month</usecase_outcome>
      <usecase_blocker>without you living in QuickBooks</usecase_blocker>,
      I'm happy to walk through how our clients set this up in a short 20‚Äì30 minute working session.<br/><br/>

      If not, feel free to just swipe the <cta_leadmagnet>template</cta_leadmagnet>.
    </BODY>
  </EMAIL>
</HIGHLIGHTED_OUTPUT_EXAMPLE>`;

  // Build play-specific variable mapping section if available
  let playSpecificSection = '';
  if (playConfig && variablesByCategory) {
    playSpecificSection = `
**PLAY-SPECIFIC PROMPT TEMPLATE AND VARIABLE MAPPINGS:**

This play (${playCode}) uses a specific prompt template with variables. The OUTPUT content was generated by filling in these variables. Your task is to identify which parts of the OUTPUT correspond to which variables from the template.

**PROMPT TEMPLATE VARIABLES BY CATEGORY:**

${variablesByCategory.persona.length > 0 ? `**PERSONA variables (map to <persona> tag):**
${variablesByCategory.persona.map(v => `- {{${v}}}`).join('\n')}
These variables describe the target persona/ICP. Look for text in the OUTPUT that matches or describes these persona characteristics.` : ''}

${variablesByCategory.segment.length > 0 ? `**SEGMENT variables (map to <segment> tag):**
${variablesByCategory.segment.map(v => `- {{${v}}}`).join('\n')}
These variables describe company segments. Look for text in the OUTPUT that matches these segment characteristics.` : ''}

${variablesByCategory.usecase_outcome.length > 0 ? `**USE CASE OUTCOME variables (map to <usecase_outcome> tag):**
${variablesByCategory.usecase_outcome.map(v => `- {{${v}}}`).join('\n')}
These variables describe desired outcomes/goals. Look for text in the OUTPUT that matches or describes these outcomes.` : ''}

${variablesByCategory.usecase_blocker.length > 0 ? `**USE CASE BLOCKER variables (map to <usecase_blocker> tag):**
${variablesByCategory.usecase_blocker.map(v => `- {{${v}}}`).join('\n')}
These variables describe problems/blockers. Look for text in the OUTPUT that matches or describes these problems.` : ''}

${variablesByCategory.cta_leadmagnet.length > 0 ? `**CTA/LEAD MAGNET variables (map to <cta_leadmagnet> tag):**
${variablesByCategory.cta_leadmagnet.map(v => `- {{${v}}}`).join('\n')}
These variables describe offers, resources, links, or CTAs. Look for text in the OUTPUT that matches these offers/resources.` : ''}

${variablesByCategory.personalization.length > 0 ? `**PERSONALIZATION variables (map to <personalization> tag):**
${variablesByCategory.personalization.map(v => `- {{${v}}}`).join('\n')}
These variables contain personalized information like names, company names, specific details. Look for text in the OUTPUT that matches these personalized elements.` : ''}

**CRITICAL INSTRUCTION:** 
For each variable listed above, find the corresponding text in the OUTPUT that was generated to fill that variable. The OUTPUT text may not exactly match the variable name - it will be the actual content that was generated. For example, if the template has {{FIRST_NAME}}, look for actual names in the OUTPUT like "John" or "Sarah". If the template has {{PRIMARY_OUTCOME}}, look for the actual outcome description in the OUTPUT.

**PROMPT TEMPLATE (for reference - shows context of how variables are used):**
\`\`\`
${playConfig.promptTemplate.substring(0, 2000)}${playConfig.promptTemplate.length > 2000 ? '\n... [truncated for length]' : ''}
\`\`\`

`;
  }

  const prompt = `You are an expert at analyzing marketing content and identifying which parts correspond to specific input elements.

**CRITICAL: YOU MUST PRESERVE EVERY SINGLE CHARACTER OF THE ORIGINAL OUTPUT. DO NOT ADD, REMOVE, OR MODIFY ANY TEXT, HEADERS, LABELS, STRUCTURE, OR FORMATTING.**

Your ONLY task is to wrap specific text segments with XML tags. You must NOT:
- Remove any headers, titles, or labels (e.g., "Day Zero Cold Call", "Subject Line:", "Body:", "0002", etc.)
- Change any formatting, line breaks, or structure
- Add or remove any content
- Modify any existing text

Your task is to analyze the OUTPUT content and identify which text segments correspond to:
1. **OCTAVE_ELEMENTS** (from library):
   - <persona> - References to the target persona (e.g., "CEOs", "CFOs", "Marketing Directors")
   - <segment> - Company size, industry, or demographic segments (e.g., "under $10M", "SaaS companies")
   - <usecase_outcome> - Desired outcomes/goals from use cases (e.g., "clean numbers", "better reporting")
   - <usecase_blocker> - Problems/blockers from use cases (e.g., "without living in QuickBooks", "gut feel")
   - <cta_leadmagnet> - Call-to-action or lead magnet references (e.g., "template", "guide", "Link here")

2. **OCTAVE_CONTENT_AGENT_PERSONALIZATION** (runtime/generated):
   - <personalization> - Personalized information like names, company names, specific details that were generated at runtime (e.g., "John", "McGreggor Law")

${playSpecificSection}

**RUNTIME CONTEXT PROVIDED:**
- Personas: ${personaNames}
- Use Cases: ${useCaseNames}
- Use Case Outcomes: ${useCaseOutcomes}
- Use Case Blockers: ${useCaseBlockers}
- Client References: ${referenceNames}

**HOW TO IDENTIFY SEMANTIC MATCHES (CRITICAL):**

**PERSONA (<persona> tag):**
- Look for references to WHO the target audience is - job titles, role descriptions, types of people/organizations
- Examples: "CEOs", "CFOs", "IP law partners", "legal professionals", "patent attorneys", "law firm partners"
- Phrases like "when we see that from [X]" where [X] describes a type of person or organization
- Phrases describing the target audience type (e.g., "IP law partners", "mid-market companies", "B2B SaaS founders")
- DO NOT highlight specific company names (those are personalization) - only highlight role/type descriptions
- Think: "Who is this targeting?" or "What type of person/organization is this about?"

**USE CASE OUTCOME (<usecase_outcome> tag):**
- Look for references to WHAT they want to achieve, accomplish, or obtain - goals, desired results, objectives
- Examples: "clean numbers", "better reporting", "complete confidence in patent applications", "identifying critical prior art", "Invention Prior Art Discovery"
- Phrases describing outcomes, results, goals, or what they're trying to accomplish
- Action phrases that describe achievements or objectives (e.g., "identifying critical prior art", "discovering prior art", "ensuring patent validity", "maximize enforceable scope")
- Look for phrases that answer "what do they want?" or "what are they trying to achieve?" or "what outcome are they seeking?"
- Think: "What is the desired end result?" or "What goal are they pursuing?"

**USE CASE BLOCKER (<usecase_blocker> tag):**
- Look for references to WHAT'S PREVENTING them or WHAT PROBLEMS they face - challenges, obstacles, pain points
- Examples: "without living in QuickBooks", "gut feel", "lack of resources", "manual processes", "inefficient workflows"
- Phrases describing challenges, problems, obstacles, or things that are blocking progress
- Look for phrases that answer "what's preventing them?" or "what problems do they have?" or "what's blocking their success?"
- Think: "What is the problem or obstacle?" or "What's preventing them from achieving their goal?"

**SEGMENT (<segment> tag):**
- Look for company size, industry, or demographic descriptions
- Examples: "under $10M", "SaaS companies", "mid-market", "enterprise", "B2B companies"
- Company characteristics that segment the audience by size, industry, or type

**CTA/LEAD MAGNET (<cta_leadmagnet> tag):**
- Look for offers, resources, links, or calls-to-action
- Examples: "template", "guide", "Link here", "scheduling link", "free assessment", "download"

**PERSONALIZATION (<personalization> tag):**
- Look for specific names, company names, or dynamically inserted details
- Examples: "John", "McGreggor Law", specific company names, specific dates/times, specific locations

**CRITICAL SEMANTIC MATCHING RULES:**
1. **Don't just look for exact matches** - the OUTPUT text may be paraphrased or reworded from the input variables. Focus on MEANING, not exact words.
2. **Think about semantic relationships** - "IP law partners" means the same as "IP attorneys" or "patent law professionals" - all are personas
3. **Look for context clues** - Phrases like "when we see that from [X]" indicate [X] is a persona. Phrases like "related to [X]" or "about [X]" often indicate outcomes or blockers.
4. **Outcomes vs Blockers**: Outcomes describe what they WANT (positive/aspirational). Blockers describe what's PREVENTING them (negative/problematic).
5. **Personas vs Segments**: Personas are WHO (people/roles/organization types). Segments are WHAT KIND OF COMPANY (size/industry characteristics).
6. **Be generous with highlighting** - If you're unsure between two categories, choose the more specific one, but DO highlight it. It's better to highlight something that might be borderline than to miss it entirely.
7. **Multiple highlights in one sentence are OK** - A single sentence can contain multiple elements (e.g., "When [persona] want [outcome] but face [blocker]")

**STRICT INSTRUCTIONS:**
1. Read the OUTPUT content EXACTLY as provided
2. Identify text segments that semantically match the input elements above using the guidance above
3. Wrap ONLY those matching segments with XML tags (e.g., <persona>text</persona>)
4. DO NOT wrap headers, labels, titles, or structural elements
5. DO NOT modify, add, or remove ANY text
6. Preserve ALL original formatting, line breaks, HTML tags, headers, labels, and structure EXACTLY as they appear
7. If a segment could match multiple categories, choose the most specific one
8. Personalization tags should be used for specific names, companies, or details that appear to be dynamically inserted

**EXAMPLE OUTPUT FORMAT:**
${exampleOutput}

**OUTPUT TO ANALYZE (PRESERVE EVERYTHING EXACTLY AS IS, ONLY ADD TAGS):**
${outputContent}

**YOUR TASK:**
Return the EXACT OUTPUT content with ONLY semantic XML tags wrapping the identified segments. Every character, header, label, and structure must remain identical to the original.

**CRITICAL: DO NOT wrap your response in markdown code blocks. Return ONLY the content with XML tags, nothing else. Do not use triple backticks or any markdown formatting.**`;

  try {
    console.log('üé® ===== STARTING OUTPUT HIGHLIGHTING =====');
    console.log(`üìù Input content length: ${outputContent.length} characters`);
    console.log(`üéØ Play code: ${playCode || 'GENERIC (no play code)'}`);
    console.log(`üë• Context: ${runtimeContext.personas?.length || 0} personas, ${runtimeContext.useCases?.length || 0} use cases, ${runtimeContext.clientReferences?.length || 0} references`);
    
    if (playCode && playConfig) {
      console.log(`‚úÖ Play-specific config found for play ${playCode}`);
      console.log(`   Agent ID: ${playConfig.agentId}`);
      console.log(`   Total variables: ${Object.keys(playConfig.variableMappings).length}`);
      const varCounts = Object.values(playConfig.variableMappings).reduce((acc, cat) => {
        acc[cat] = (acc[cat] || 0) + 1;
        return acc;
      }, {} as Record<HighlightCategory, number>);
      console.log(`   Variable breakdown:`);
      console.log(`     - Persona: ${varCounts.persona || 0}`);
      console.log(`     - Segment: ${varCounts.segment || 0}`);
      console.log(`     - Use Case Outcome: ${varCounts.usecase_outcome || 0}`);
      console.log(`     - Use Case Blocker: ${varCounts.usecase_blocker || 0}`);
      console.log(`     - CTA/Lead Magnet: ${varCounts.cta_leadmagnet || 0}`);
      console.log(`     - Personalization: ${varCounts.personalization || 0}`);
    } else {
      console.warn('‚ö†Ô∏è No play-specific prompt found, using generic highlighting');
      if (playCode) {
        console.warn(`   Play code ${playCode} was provided but no config found - check play-prompts.ts`);
      }
    }
    
    console.log(`ü§ñ Calling OpenAI API (gpt-4o-mini)...`);
    const startTime = Date.now();
    
    // Calculate max_tokens based on input size
    // Rough estimate: 1 token ‚âà 4 characters, but highlighted output can be longer
    // For 18980 chars input, that's ~4750 tokens, highlighted might be ~6000-8000 tokens
    // OpenAI max is 16384 for gpt-4o-mini, use 16000 to be safe
    const inputTokens = Math.ceil(outputContent.length / 4);
    const estimatedMaxTokens = Math.min(16000, Math.max(8000, inputTokens * 2));
    console.log(`üìä Input tokens estimate: ~${inputTokens}, max_tokens set to: ${estimatedMaxTokens}`);
    
    // Create AbortController for timeout
    // For large content (18k+ chars), allow up to 4 minutes
    // Smaller content gets 2 minutes
    const timeoutDuration = outputContent.length > 15000 ? 240000 : 120000; // 4 min for large, 2 min for normal
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
    console.log(`‚è±Ô∏è Timeout set to ${timeoutDuration / 1000} seconds for ${outputContent.length} character content`);
    
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: "You are an expert content analyst specializing in identifying semantic relationships between marketing content and input elements. Your ONLY job is to wrap text segments with XML tags. You MUST preserve every single character of the original content - do not add, remove, or modify any text, headers, labels, or structure. Only wrap matching segments with tags."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.1, // Low temperature for consistency
        max_tokens: estimatedMaxTokens
      }, {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      const duration = Date.now() - startTime;
      console.log(`‚è±Ô∏è OpenAI API call completed in ${duration}ms`);
      
      let highlightedContent = completion.choices[0]?.message?.content || outputContent;
      console.log(`üìÑ Raw response length: ${highlightedContent.length} characters`);
      
      // Strip markdown code blocks if LLM added them (e.g., ```xml ... ```)
      const beforeStrip = highlightedContent.length;
      highlightedContent = highlightedContent.replace(/^```xml\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '').trim();
      if (beforeStrip !== highlightedContent.length) {
        console.log(`üßπ Stripped markdown code blocks (${beforeStrip} ‚Üí ${highlightedContent.length} chars)`);
      }
      
      // Check if highlights were actually applied
      const hasHighlightsResult = /<(persona|segment|usecase_outcome|usecase_blocker|cta_leadmagnet|personalization)>/i.test(highlightedContent);
      console.log(`üîç Highlights detected in output: ${hasHighlightsResult ? 'YES ‚úÖ' : 'NO ‚ùå'}`);
      
      if (hasHighlightsResult) {
        // Count highlight tags
        const personaCount = (highlightedContent.match(/<persona>/gi) || []).length;
        const segmentCount = (highlightedContent.match(/<segment>/gi) || []).length;
        const outcomeCount = (highlightedContent.match(/<usecase_outcome>/gi) || []).length;
        const blockerCount = (highlightedContent.match(/<usecase_blocker>/gi) || []).length;
        const ctaCount = (highlightedContent.match(/<cta_leadmagnet>/gi) || []).length;
        const personalizationCount = (highlightedContent.match(/<personalization>/gi) || []).length;
        console.log(`üìä Highlight tag counts:`);
        console.log(`     - Persona: ${personaCount}`);
        console.log(`     - Segment: ${segmentCount}`);
        console.log(`     - Use Case Outcome: ${outcomeCount}`);
        console.log(`     - Use Case Blocker: ${blockerCount}`);
        console.log(`     - CTA/Lead Magnet: ${ctaCount}`);
        console.log(`     - Personalization: ${personalizationCount}`);
        console.log(`     - Total: ${personaCount + segmentCount + outcomeCount + blockerCount + ctaCount + personalizationCount}`);
      } else {
        console.warn(`‚ö†Ô∏è WARNING: No highlight tags found in OpenAI response!`);
        console.warn(`   This could mean:`);
        console.warn(`   1. The LLM didn't find any matches`);
        console.warn(`   2. The LLM returned plain text instead of XML`);
        console.warn(`   3. The prompt wasn't clear enough`);
        console.warn(`   Response preview (first 500 chars): ${highlightedContent.substring(0, 500)}`);
      }
      
      console.log('‚úÖ ===== HIGHLIGHTING COMPLETED =====');
      
      return highlightedContent;
      
    } catch (error: any) {
      clearTimeout(timeoutId); // Clean up timeout if error occurred
      
      // Check if it's a timeout/abort error
      if (error.name === 'AbortError' || error.message?.includes('timeout') || error.message?.includes('aborted')) {
        console.error('‚ùå ===== HIGHLIGHTING TIMEOUT =====');
        console.error(`   OpenAI API call timed out after ${timeoutDuration / 1000} seconds`);
        console.error(`   Input content length: ${outputContent.length} characters`);
        console.error(`   Estimated tokens: ~${Math.ceil(outputContent.length / 4)}`);
        console.error(`   This may be due to very large output content`);
        console.error(`   Suggestion: Content may need to be split into smaller chunks`);
        console.error('‚ùå ===== END TIMEOUT ERROR =====');
        throw new Error(`Highlighting timeout after ${timeoutDuration / 1000}s - content is ${outputContent.length} characters. Try re-highlighting or split content into smaller sections.`);
      }
      
      console.error('‚ùå ===== HIGHLIGHTING ERROR =====');
      console.error(`   Error message: ${error.message}`);
      console.error(`   Error type: ${error.constructor.name}`);
      console.error(`   Error name: ${error.name}`);
      if (error.response) {
        console.error(`   API response status: ${error.response.status}`);
        console.error(`   API response data:`, JSON.stringify(error.response.data, null, 2));
      }
      if (error.stack) {
        console.error(`   Stack trace:`, error.stack);
      }
      console.error('‚ùå ===== END ERROR =====');
      // Re-throw error so outer catch can handle it
      throw error;
    }
  } catch (outerError: any) {
    // Outer catch - handles any errors from the highlighting process
    console.error('‚ùå ===== OUTER HIGHLIGHTING ERROR =====');
    console.error(`   Error message: ${outerError.message}`);
    console.error(`   Error type: ${outerError.constructor.name}`);
    if (outerError.stack) {
      console.error(`   Stack trace:`, outerError.stack);
    }
    console.error('‚ùå ===== END OUTER ERROR =====');
    // Return original content if highlighting fails completely
    return outputContent;
  }
}

